{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview A fast and modern graphql client designed with simplicity in mind. Highlights : Automatic graphql query generation. Offline query validation Support for different Backends Quick Introduction qlient inspects the GraphQL schema and generates the corresponding code to use the operations and types in the schema. This provides an easy to use programmatic interface to a GraphQL API. Example from qlient import Client , GraphQLResponse client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) res : GraphQLResponse = client . query . film ( # swapi graphql input fields id = \"ZmlsbXM6MQ==\" , # qlient specific _fields = [ \"id\" , \"title\" , \"episodeID\" ] ) print ( res . query ) # query film($id: ID) { film(id: $id) { id title episodeID } } print ( res . variables ) # {'id': 'ZmlsbXM6MQ=='} print ( res . data ) # {'film': {'id': 'ZmlsbXM6MQ==', 'title': 'A New Hope', 'episodeID': 4}} (This script is complete and should run \"as is\") What's going on here: When instantiating a new Client, the schema will be automatically resolved from the server and introspected to build the operation proxies. Then a query will be constructed using the given kwargs for variables and special variable _fields for field selection. Now, the query combined with the given variables is sent to the server and a response is returned.","title":"Overview"},{"location":"#overview","text":"A fast and modern graphql client designed with simplicity in mind. Highlights : Automatic graphql query generation. Offline query validation Support for different Backends","title":"Overview"},{"location":"#quick-introduction","text":"qlient inspects the GraphQL schema and generates the corresponding code to use the operations and types in the schema. This provides an easy to use programmatic interface to a GraphQL API.","title":"Quick Introduction"},{"location":"#example","text":"from qlient import Client , GraphQLResponse client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) res : GraphQLResponse = client . query . film ( # swapi graphql input fields id = \"ZmlsbXM6MQ==\" , # qlient specific _fields = [ \"id\" , \"title\" , \"episodeID\" ] ) print ( res . query ) # query film($id: ID) { film(id: $id) { id title episodeID } } print ( res . variables ) # {'id': 'ZmlsbXM6MQ=='} print ( res . data ) # {'film': {'id': 'ZmlsbXM6MQ==', 'title': 'A New Hope', 'episodeID': 4}} (This script is complete and should run \"as is\") What's going on here: When instantiating a new Client, the schema will be automatically resolved from the server and introspected to build the operation proxies. Then a query will be constructed using the given kwargs for variables and special variable _fields for field selection. Now, the query combined with the given variables is sent to the server and a response is returned.","title":"Example"},{"location":"install/","text":"Installation Qlient is a pure-python module. This means that there is no C code which needs to be compiled. This package is build with poetry so installation is as you might expect. pip install qlient or using poetry poetry add qlient","title":"Installation"},{"location":"install/#installation","text":"Qlient is a pure-python module. This means that there is no C code which needs to be compiled. This package is build with poetry so installation is as you might expect. pip install qlient or using poetry poetry add qlient","title":"Installation"},{"location":"examples/project_batches/","text":"","title":"Project batches"},{"location":"examples/script_legend/","text":"(This script is complete and should run \"as is\")","title":"Script legend"},{"location":"usage/backend/","text":"Backends A backend is a service that can take a query, variables and an operation name to create a response. The most common backend is probably going to be some sort of web server, which is why I've made it the default. The default HTTP Backend Below you find an example on instantiating a simple client with an HTTPBackend . from qlient import Client , HTTPBackend , Schema client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) isinstance ( client . schema , Schema ) isinstance ( client . backend , HTTPBackend ) (This script is complete and should run \"as is\") Customizing the HTTP Backend Session For example let's say you have to do session based authentication. Since the http backend is based on requests, this can be quite easily achieved. import requests from qlient import Client , HTTPBackend session = requests . Session () session . auth = ( \"username\" , \"password\" ) authenticated_backend = HTTPBackend ( endpoint = \"https://...\" , session = session ) client = Client ( authenticated_backend ) assert isinstance ( client . backend , HTTPBackend ) assert client . backend . session == session So what's going on here: A new requests.Session instance is created The session authentication is set A new HTTPBackend with the custom session is created The client with the customized HTTPBackend is created Custom Backends But although a GraphQL API is mostly used in combination with a http backend, it's not solely bound serve over http. For example when using strawberry you can generally just execute queries locally. from typing import List import strawberry # must be installed additionally from qlient import Client , GraphQLResponse from qlient.backend import Backend from qlient.types import ( GraphQLVariables , GraphQLQuery , GraphQLOperation , GraphQLReturnType , GraphQLContext , GraphQLRoot ) @strawberry . type class Book : title : str author : str my_books = [ Book ( title = \"The Great Gatsby\" , author = \"F. Scott Fitzgerald\" ) ] @strawberry . type class Query : @strawberry . field def get_books ( self ) -> List [ Book ]: return my_books @strawberry . type class Mutation : @strawberry . mutation def add_book ( self , title : str , author : str ) -> Book : book = Book ( title = title , author = author ) my_books . append ( book ) return book # this line creates the strawberry schema my_book_schema = strawberry . Schema ( query = Query , mutation = Mutation ) # now this is the important part # down below we create a custom backend for our client # this backend executes all queries locally using the given strawberry.Schema class StrawberryBackend ( Backend ): def __init__ ( self , schema : strawberry . Schema ): self . schema = schema def execute_query ( self , query : GraphQLQuery , variables : GraphQLVariables = None , operation_name : GraphQLOperation = None , context : GraphQLContext = None , root : GraphQLRoot = None , ) -> GraphQLReturnType : # here we execute the given query on the local strawberry schema # as described in the testing section of the strawberry documentation # https://strawberry.rocks/docs/operations/testing result = self . schema . execute_sync ( query , variables , context , root , operation_name ) return { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , } @property def cache_key ( self ) -> str : # required for caching purposes (not used in this example) return \"CustomStrawberryBookBackend\" client = Client ( StrawberryBackend ( my_book_schema )) # note that the operation is now named \"getBooks\" # instead of the actual method \"get_books\" # This is due to the automatic camel case conversation in strawberry # https://strawberry.rocks/docs/types/schema-configurations response : GraphQLResponse = client . query . getBooks ( _fields = [ \"title\" , \"author\" ]) print ( response . data ) # {\"getBooks\": [{\"title\": \"The Great Gatsby\", \"author\": \"F. Scott Fitzgerald\"}]} response : GraphQLResponse = client . mutation . addBook ( title = \"1984\" , author = \"George Orwell\" , _fields = [ \"title\" , \"author\" ] ) print ( response . data ) # { # \"addBook\": { # \"title\": \"1984\", # \"author\": \"George Orwell\" # } # } response : GraphQLResponse = client . query . getBooks ( _fields = [ \"title\" , \"author\" ]) print ( response . data ) # { # \"getBooks\": [ # {\"title\": \"The Great Gatsby\", \"author\": \"F. Scott Fitzgerald\"}, # {\"title\": \"1984\", \"author\": \"George Orwell\"} # ] # } (This script is complete and should run \"as is\") So what's going on here: After all imports are done the strawberry schema is created Once we have the schema, it's time to create our backend. For that we must import the base Backend class from qlient.backend . Then we implement the required abstract methods execute_query and add the cache_key property. (Later is used for using the client with a cache. But this is not necessary in this case.) Once we have our custom backend, all we have to do now is to create our client. Now we can use the client just like any other http client","title":"Backends"},{"location":"usage/backend/#backends","text":"A backend is a service that can take a query, variables and an operation name to create a response. The most common backend is probably going to be some sort of web server, which is why I've made it the default.","title":"Backends"},{"location":"usage/backend/#the-default-http-backend","text":"Below you find an example on instantiating a simple client with an HTTPBackend . from qlient import Client , HTTPBackend , Schema client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) isinstance ( client . schema , Schema ) isinstance ( client . backend , HTTPBackend ) (This script is complete and should run \"as is\")","title":"The default HTTP Backend"},{"location":"usage/backend/#customizing-the-http-backend-session","text":"For example let's say you have to do session based authentication. Since the http backend is based on requests, this can be quite easily achieved. import requests from qlient import Client , HTTPBackend session = requests . Session () session . auth = ( \"username\" , \"password\" ) authenticated_backend = HTTPBackend ( endpoint = \"https://...\" , session = session ) client = Client ( authenticated_backend ) assert isinstance ( client . backend , HTTPBackend ) assert client . backend . session == session So what's going on here: A new requests.Session instance is created The session authentication is set A new HTTPBackend with the custom session is created The client with the customized HTTPBackend is created","title":"Customizing the HTTP Backend Session"},{"location":"usage/backend/#custom-backends","text":"But although a GraphQL API is mostly used in combination with a http backend, it's not solely bound serve over http. For example when using strawberry you can generally just execute queries locally. from typing import List import strawberry # must be installed additionally from qlient import Client , GraphQLResponse from qlient.backend import Backend from qlient.types import ( GraphQLVariables , GraphQLQuery , GraphQLOperation , GraphQLReturnType , GraphQLContext , GraphQLRoot ) @strawberry . type class Book : title : str author : str my_books = [ Book ( title = \"The Great Gatsby\" , author = \"F. Scott Fitzgerald\" ) ] @strawberry . type class Query : @strawberry . field def get_books ( self ) -> List [ Book ]: return my_books @strawberry . type class Mutation : @strawberry . mutation def add_book ( self , title : str , author : str ) -> Book : book = Book ( title = title , author = author ) my_books . append ( book ) return book # this line creates the strawberry schema my_book_schema = strawberry . Schema ( query = Query , mutation = Mutation ) # now this is the important part # down below we create a custom backend for our client # this backend executes all queries locally using the given strawberry.Schema class StrawberryBackend ( Backend ): def __init__ ( self , schema : strawberry . Schema ): self . schema = schema def execute_query ( self , query : GraphQLQuery , variables : GraphQLVariables = None , operation_name : GraphQLOperation = None , context : GraphQLContext = None , root : GraphQLRoot = None , ) -> GraphQLReturnType : # here we execute the given query on the local strawberry schema # as described in the testing section of the strawberry documentation # https://strawberry.rocks/docs/operations/testing result = self . schema . execute_sync ( query , variables , context , root , operation_name ) return { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , } @property def cache_key ( self ) -> str : # required for caching purposes (not used in this example) return \"CustomStrawberryBookBackend\" client = Client ( StrawberryBackend ( my_book_schema )) # note that the operation is now named \"getBooks\" # instead of the actual method \"get_books\" # This is due to the automatic camel case conversation in strawberry # https://strawberry.rocks/docs/types/schema-configurations response : GraphQLResponse = client . query . getBooks ( _fields = [ \"title\" , \"author\" ]) print ( response . data ) # {\"getBooks\": [{\"title\": \"The Great Gatsby\", \"author\": \"F. Scott Fitzgerald\"}]} response : GraphQLResponse = client . mutation . addBook ( title = \"1984\" , author = \"George Orwell\" , _fields = [ \"title\" , \"author\" ] ) print ( response . data ) # { # \"addBook\": { # \"title\": \"1984\", # \"author\": \"George Orwell\" # } # } response : GraphQLResponse = client . query . getBooks ( _fields = [ \"title\" , \"author\" ]) print ( response . data ) # { # \"getBooks\": [ # {\"title\": \"The Great Gatsby\", \"author\": \"F. Scott Fitzgerald\"}, # {\"title\": \"1984\", \"author\": \"George Orwell\"} # ] # } (This script is complete and should run \"as is\") So what's going on here: After all imports are done the strawberry schema is created Once we have the schema, it's time to create our backend. For that we must import the base Backend class from qlient.backend . Then we implement the required abstract methods execute_query and add the cache_key property. (Later is used for using the client with a cache. But this is not necessary in this case.) Once we have our custom backend, all we have to do now is to create our client. Now we can use the client just like any other http client","title":"Custom Backends"},{"location":"usage/cache/","text":"Cache When the client is initialized, it will automatically retrieve the schema using the given provider. By default, qlient does not cache these files, but it is however advised to enable this for performance reasons. This library comes with two built in Caching Backends. InMemoryCache The InMemoryCache caches, as the name suggests, everything in memory. This is useful when you create a lot of clients in a short period of time. from qlient import Client from qlient.cache import InMemoryCache client = Client ( \"https://...\" , cache = InMemoryCache ()) SqliteCache The SqliteCache uses pythons built in sqlite3 package to cache the schema in a .sqlite file. By default, this file is stored in the application cache folder of your operating system. Linux: /home/{USER}/.cache/qlient/schemas.sqlite Windows: C:/Users/{USER}/AppData/Local/qlient/Cache/schemas.sqlite Mac: /Users/{USER}/Library/Caches/qlient/schemas.sqlite However, the path can be adjusted to your liking. from qlient import Client , Settings from qlient.cache import SqliteCache client = Client ( \"https://...\" , cache = SqliteCache ()) # or with custom settings settings = Settings ( json_loads =... , # uses json.loads by default, can be overwritten to ujson.loads json_dumps =... , # and ujson.dumps ) client = Client ( \"https://...\" , cache = SqliteCache ( path = \"/path/to/my/schema_cache.sqlite\" , expires_in = 86400 , # seconds settings = settings , ) )","title":"Cache"},{"location":"usage/cache/#cache","text":"When the client is initialized, it will automatically retrieve the schema using the given provider. By default, qlient does not cache these files, but it is however advised to enable this for performance reasons. This library comes with two built in Caching Backends.","title":"Cache"},{"location":"usage/cache/#inmemorycache","text":"The InMemoryCache caches, as the name suggests, everything in memory. This is useful when you create a lot of clients in a short period of time. from qlient import Client from qlient.cache import InMemoryCache client = Client ( \"https://...\" , cache = InMemoryCache ())","title":"InMemoryCache"},{"location":"usage/cache/#sqlitecache","text":"The SqliteCache uses pythons built in sqlite3 package to cache the schema in a .sqlite file. By default, this file is stored in the application cache folder of your operating system. Linux: /home/{USER}/.cache/qlient/schemas.sqlite Windows: C:/Users/{USER}/AppData/Local/qlient/Cache/schemas.sqlite Mac: /Users/{USER}/Library/Caches/qlient/schemas.sqlite However, the path can be adjusted to your liking. from qlient import Client , Settings from qlient.cache import SqliteCache client = Client ( \"https://...\" , cache = SqliteCache ()) # or with custom settings settings = Settings ( json_loads =... , # uses json.loads by default, can be overwritten to ujson.loads json_dumps =... , # and ujson.dumps ) client = Client ( \"https://...\" , cache = SqliteCache ( path = \"/path/to/my/schema_cache.sqlite\" , expires_in = 86400 , # seconds settings = settings , ) )","title":"SqliteCache"},{"location":"usage/client/","text":"Client The Client is the main interface for interacting with the graphql server. It provides the query , mutation and subscription attribute which references the different types of operations (via ServiceProxy class). Configuring a default client The client takes one required argument (the backend ) and several optional arguments which all have an impact on the client behaviour. from qlient import Client , HTTPBackend , Schema client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) isinstance ( client . schema , Schema ) isinstance ( client . backend , HTTPBackend ) (This script is complete and should run \"as is\") Initiating a client like so will make a request to the graphql server to inspect the schema. For more details on the schema, have a look at the schema documentation . If you want to get to know the backend, have a look at the backend documentation . Making a request Let's say we already have our default client setup. Now how do we make requests? Below is an example for the star wars api from qlient import Client , GraphQLResponse client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) res : GraphQLResponse = client . query . film ( # swapi graphql input fields id = \"ZmlsbXM6MQ==\" , # qlient specific _fields = [ \"id\" , \"title\" , \"episodeID\" ] ) print ( res . query ) # query film($id: ID) { film(id: $id) { id title episodeID } } print ( res . variables ) # {'id': 'ZmlsbXM6MQ=='} print ( res . data ) # {'film': {'id': 'ZmlsbXM6MQ==', 'title': 'A New Hope', 'episodeID': 4}} (This script is complete and should run \"as is\") Selecting nested fields You can use the Fields class to make powerful selections. Say for the example above, you'd also like to have information about the rocket. from qlient import Client , Fields client : Client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) nested_fields = Fields ( people = Fields ( \"id\" , \"name\" , homeworld = \"name\" ) ) response = client . query . allPeople ( first = 3 , _fields = nested_fields ) print ( response . query ) # query allPeople($first: Int) { allPeople(first: $first) { people { id name homeworld { name } } } } (This script is complete and should run \"as is\") For more details on the Fields class, have a look at the fields documentation Sending custom queries Please have a look at the proxy documentation","title":"Client"},{"location":"usage/client/#client","text":"The Client is the main interface for interacting with the graphql server. It provides the query , mutation and subscription attribute which references the different types of operations (via ServiceProxy class).","title":"Client"},{"location":"usage/client/#configuring-a-default-client","text":"The client takes one required argument (the backend ) and several optional arguments which all have an impact on the client behaviour. from qlient import Client , HTTPBackend , Schema client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) isinstance ( client . schema , Schema ) isinstance ( client . backend , HTTPBackend ) (This script is complete and should run \"as is\") Initiating a client like so will make a request to the graphql server to inspect the schema. For more details on the schema, have a look at the schema documentation . If you want to get to know the backend, have a look at the backend documentation .","title":"Configuring a default client"},{"location":"usage/client/#making-a-request","text":"Let's say we already have our default client setup. Now how do we make requests? Below is an example for the star wars api from qlient import Client , GraphQLResponse client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) res : GraphQLResponse = client . query . film ( # swapi graphql input fields id = \"ZmlsbXM6MQ==\" , # qlient specific _fields = [ \"id\" , \"title\" , \"episodeID\" ] ) print ( res . query ) # query film($id: ID) { film(id: $id) { id title episodeID } } print ( res . variables ) # {'id': 'ZmlsbXM6MQ=='} print ( res . data ) # {'film': {'id': 'ZmlsbXM6MQ==', 'title': 'A New Hope', 'episodeID': 4}} (This script is complete and should run \"as is\")","title":"Making a request"},{"location":"usage/client/#selecting-nested-fields","text":"You can use the Fields class to make powerful selections. Say for the example above, you'd also like to have information about the rocket. from qlient import Client , Fields client : Client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) nested_fields = Fields ( people = Fields ( \"id\" , \"name\" , homeworld = \"name\" ) ) response = client . query . allPeople ( first = 3 , _fields = nested_fields ) print ( response . query ) # query allPeople($first: Int) { allPeople(first: $first) { people { id name homeworld { name } } } } (This script is complete and should run \"as is\") For more details on the Fields class, have a look at the fields documentation","title":"Selecting nested fields"},{"location":"usage/client/#sending-custom-queries","text":"Please have a look at the proxy documentation","title":"Sending custom queries"},{"location":"usage/fields/","text":"Field and Fields The Fields class is a powerful class for making nested or pre-configured field selections. In combination with the Field class you can create every query you need. Using the Field Class The Field class supports all major graphql features ranging from name, alias to directives and field inputs. from qlient import Field , Directive my_field = Field ( # Mandatory, the name of the field \"repository\" , # Schema Field specific inputs # say we want the last 5 repositories where the name matches abc last = 5 , name = \"*abc*\" , # Qlient Field specific arguments start with a `_` # These arguments are Optional and can be left empty # Optional, the alias of the field _alias = \"my_repo\" , # Optional, a field directive _directive = Directive ( \"include\" , ** { \"if\" : True }), ) # This results in a field like so: # { # my_repo: repository(last: $repository_1234_last name: $repository_1234_name) @include(if: $include_5678_if) # } (This script is complete and should run \"as is\") Using the Fields Class from qlient import Fields nested_fields = Fields ( \"first_name\" , # will be converted to Field(\"first_name\") \"last_name\" , # will be converted to Field(\"first_name\") # This will be converted to # Field( # \"hobby\", # _sub_fields=Fields( # Field(\"name\"), # Field(\"club\", _sub_fields=Fields(Field(\"name\"))) # ) # ) hobby = Fields ( \"name\" , club = \"name\" ) ) # last_name first_name hobby { name club { name } } (This script is complete and should run \"as is\") Supported Operators Both, the Field and Fields class currently support the following operators: Addition from qlient import Fields , Field name_fields = Fields ( \"first_name\" , \"last_name\" ) age_field = Field ( \"age\" ) person_fields = name_fields + age_field # { first_name last_name age } (This script is complete and should run \"as is\") Combination of Fields and Field from qlient import Fields , Field , Directive my_home_world_selection = Fields ( \"id\" , \"name\" , \"population\" ) my_person_selection = Fields ( \"id\" , # will be converted to Field(\"id\") Field ( \"name\" ), Field ( \"height\" , _alias = \"my_height\" ), Field ( \"homeworld\" , _sub_fields = my_home_world_selection , _directive = Directive ( \"include\" , ** { \"if\" : True })) ) # Every variable name used in a Field or Directive is automatically generated and therefore unique. # { # id # name # my_height: height # homeworld @include(if: $include_123456789_if) { # id # name # population # } # }","title":"Field and Fields"},{"location":"usage/fields/#field-and-fields","text":"The Fields class is a powerful class for making nested or pre-configured field selections. In combination with the Field class you can create every query you need.","title":"Field and Fields"},{"location":"usage/fields/#using-the-field-class","text":"The Field class supports all major graphql features ranging from name, alias to directives and field inputs. from qlient import Field , Directive my_field = Field ( # Mandatory, the name of the field \"repository\" , # Schema Field specific inputs # say we want the last 5 repositories where the name matches abc last = 5 , name = \"*abc*\" , # Qlient Field specific arguments start with a `_` # These arguments are Optional and can be left empty # Optional, the alias of the field _alias = \"my_repo\" , # Optional, a field directive _directive = Directive ( \"include\" , ** { \"if\" : True }), ) # This results in a field like so: # { # my_repo: repository(last: $repository_1234_last name: $repository_1234_name) @include(if: $include_5678_if) # } (This script is complete and should run \"as is\")","title":"Using the Field Class"},{"location":"usage/fields/#using-the-fields-class","text":"from qlient import Fields nested_fields = Fields ( \"first_name\" , # will be converted to Field(\"first_name\") \"last_name\" , # will be converted to Field(\"first_name\") # This will be converted to # Field( # \"hobby\", # _sub_fields=Fields( # Field(\"name\"), # Field(\"club\", _sub_fields=Fields(Field(\"name\"))) # ) # ) hobby = Fields ( \"name\" , club = \"name\" ) ) # last_name first_name hobby { name club { name } } (This script is complete and should run \"as is\")","title":"Using the Fields Class"},{"location":"usage/fields/#supported-operators","text":"Both, the Field and Fields class currently support the following operators:","title":"Supported Operators"},{"location":"usage/fields/#addition","text":"from qlient import Fields , Field name_fields = Fields ( \"first_name\" , \"last_name\" ) age_field = Field ( \"age\" ) person_fields = name_fields + age_field # { first_name last_name age } (This script is complete and should run \"as is\")","title":"Addition"},{"location":"usage/fields/#combination-of-fields-and-field","text":"from qlient import Fields , Field , Directive my_home_world_selection = Fields ( \"id\" , \"name\" , \"population\" ) my_person_selection = Fields ( \"id\" , # will be converted to Field(\"id\") Field ( \"name\" ), Field ( \"height\" , _alias = \"my_height\" ), Field ( \"homeworld\" , _sub_fields = my_home_world_selection , _directive = Directive ( \"include\" , ** { \"if\" : True })) ) # Every variable name used in a Field or Directive is automatically generated and therefore unique. # { # id # name # my_height: height # homeworld @include(if: $include_123456789_if) { # id # name # population # } # }","title":"Combination of Fields and Field"},{"location":"usage/proxy/","text":"Proxy The OperationServiceProxy object is a simple object which will check if an operation exists for attribute or item requested. If the operation exists then it will return an OperationProxy object (callable) which is responsible for calling the operation on the binding. from qlient import Client client = Client ( \"https://my-graphql-api.com/\" ) # query is a QueryServiceProxy object (Inherits from OperationServiceProxy). It will check if there # is an operation with the name `X` defined in the binding # and if that is the case it will return a callable OperationProxy object client . query . X () # The operation can also be called via an __getitem__ call. # This is useful if the operation name is not a valid # python attribute name. client . query [ \"X-Y-Z\" ]() # in GraphQL, you can do more than just query data. # for example mutations. client . mutation . changeX () # Subscriptions are not yet supported. Sending custom queries If you want to send your own custom queries, say because you want to send multiple queries or have fragments, you can use any proxy class. NOTE : No validation is done to neither the query, nor the variables. from qlient import Client my_client = Client ( \"https://...\" ) my_query = \"\"\" query { user1: user(id: \"1234\") { ...userInformation } user2: user(id: \"5678\") { ...userInformation } } fragment userInformation on user { username firstname lastname } \"\"\" response = my_client . query ( query = my_query )","title":"Proxy"},{"location":"usage/proxy/#proxy","text":"The OperationServiceProxy object is a simple object which will check if an operation exists for attribute or item requested. If the operation exists then it will return an OperationProxy object (callable) which is responsible for calling the operation on the binding. from qlient import Client client = Client ( \"https://my-graphql-api.com/\" ) # query is a QueryServiceProxy object (Inherits from OperationServiceProxy). It will check if there # is an operation with the name `X` defined in the binding # and if that is the case it will return a callable OperationProxy object client . query . X () # The operation can also be called via an __getitem__ call. # This is useful if the operation name is not a valid # python attribute name. client . query [ \"X-Y-Z\" ]() # in GraphQL, you can do more than just query data. # for example mutations. client . mutation . changeX () # Subscriptions are not yet supported.","title":"Proxy"},{"location":"usage/proxy/#sending-custom-queries","text":"If you want to send your own custom queries, say because you want to send multiple queries or have fragments, you can use any proxy class. NOTE : No validation is done to neither the query, nor the variables. from qlient import Client my_client = Client ( \"https://...\" ) my_query = \"\"\" query { user1: user(id: \"1234\") { ...userInformation } user2: user(id: \"5678\") { ...userInformation } } fragment userInformation on user { username firstname lastname } \"\"\" response = my_client . query ( query = my_query )","title":"Sending custom queries"},{"location":"usage/schema/","text":"Schema The schema describes what operations can be made, which inputs can be given and which return values are expected. By default, the schema will be introspected using the BackendSchemaProvider . The BackendSchemaProvider takes the in the client specified backend and uses an introspection query to load the schema from the backend. Custom Schema In some cases, for example when the introspection has been disabled on the graphql backend, you'd want to read the schema from a different location. This can be for example from a local file. Thanks to the SchemaProvider base class, this can quite easily be achieved. Schema from local path Below shows an example that reads the schema from a local path on the file system. from pathlib import Path from qlient import Client , Schema from qlient.schema.providers import FileSchemaProvider path_to_schema = Path ( \"./path/to/my/schema.json\" ) local_schema = Schema ( provider = FileSchemaProvider ( path_to_schema )) client = Client ( \"https://...\" , schema = local_schema ) My schema is neither on my filesystem, nor on any remote Do not fear, solution is near. have a look at the documentation for schema providers","title":"Schema"},{"location":"usage/schema/#schema","text":"The schema describes what operations can be made, which inputs can be given and which return values are expected. By default, the schema will be introspected using the BackendSchemaProvider . The BackendSchemaProvider takes the in the client specified backend and uses an introspection query to load the schema from the backend.","title":"Schema"},{"location":"usage/schema/#custom-schema","text":"In some cases, for example when the introspection has been disabled on the graphql backend, you'd want to read the schema from a different location. This can be for example from a local file. Thanks to the SchemaProvider base class, this can quite easily be achieved.","title":"Custom Schema"},{"location":"usage/schema/#schema-from-local-path","text":"Below shows an example that reads the schema from a local path on the file system. from pathlib import Path from qlient import Client , Schema from qlient.schema.providers import FileSchemaProvider path_to_schema = Path ( \"./path/to/my/schema.json\" ) local_schema = Schema ( provider = FileSchemaProvider ( path_to_schema )) client = Client ( \"https://...\" , schema = local_schema )","title":"Schema from local path"},{"location":"usage/schema/#my-schema-is-neither-on-my-filesystem-nor-on-any-remote","text":"Do not fear, solution is near. have a look at the documentation for schema providers","title":"My schema is neither on my filesystem, nor on any remote"},{"location":"usage/schema_providers/","text":"Schema Providers What if my schema is neither located on my filesystem, nor is it on any backend? Do not fear, solution is near. Under the hood, the schema uses SchemaProvider s. This package comes with three built in providers: The StaticSchemaProvider in case you have a static dictionary with the schema The FileSchemaProvider in case your schema is on your disk The BackendSchemaProvider in case your schema can be obtained from the backend ( Backend Introspection only works when allowed by the graphql backend. ) If neither of these two built in providers suit your needs, you can create your own schema provider like so: from typing import Dict from qlient import Client , Schema from qlient.schema.providers import SchemaProvider class MySchemaProvider ( SchemaProvider ): def load_schema ( self ) -> Dict : # do some logic that loads your schema return { ... } my_schema = Schema ( provider = MySchemaProvider ()) client = Client ( \"https://...\" , schema = my_schema )","title":"Schema Providers"},{"location":"usage/schema_providers/#schema-providers","text":"What if my schema is neither located on my filesystem, nor is it on any backend? Do not fear, solution is near. Under the hood, the schema uses SchemaProvider s. This package comes with three built in providers: The StaticSchemaProvider in case you have a static dictionary with the schema The FileSchemaProvider in case your schema is on your disk The BackendSchemaProvider in case your schema can be obtained from the backend ( Backend Introspection only works when allowed by the graphql backend. ) If neither of these two built in providers suit your needs, you can create your own schema provider like so: from typing import Dict from qlient import Client , Schema from qlient.schema.providers import SchemaProvider class MySchemaProvider ( SchemaProvider ): def load_schema ( self ) -> Dict : # do some logic that loads your schema return { ... } my_schema = Schema ( provider = MySchemaProvider ()) client = Client ( \"https://...\" , schema = my_schema )","title":"Schema Providers"},{"location":"usage/settings/","text":"Settings The client behaviour can be influenced by these settings. import json from qlient import Settings , Client my_settings = Settings ( introspect = True , # default, enable backend schema introspection validate_fields = True , # default, enable query field selection validation validate_variables = True , # default, enable query variable validation, json_dumps = json . dumps , # default, use python's builtin json.dumps for internal dumping json_loads = json . loads , # default, use python's builtin json.loads for internal loading ) my_client = Client ( \"https://...\" , settings = my_settings )","title":"Settings"},{"location":"usage/settings/#settings","text":"The client behaviour can be influenced by these settings. import json from qlient import Settings , Client my_settings = Settings ( introspect = True , # default, enable backend schema introspection validate_fields = True , # default, enable query field selection validation validate_variables = True , # default, enable query variable validation, json_dumps = json . dumps , # default, use python's builtin json.dumps for internal dumping json_loads = json . loads , # default, use python's builtin json.loads for internal loading ) my_client = Client ( \"https://...\" , settings = my_settings )","title":"Settings"}]}