{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview A fast and modern graphql client designed with simplicity in mind. Highlights : Automatic graphql query generation. Offline query validation Support for different Backends Quick Introduction qlient inspects the GraphQL schema and generates the corresponding code to use the operations and types in the schema. This provides an easy to use programmatic interface to a GraphQL API. Example from qlient import Client , GraphQLResponse client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) res : GraphQLResponse = client . query . film ( # swapi graphql input fields id = \"ZmlsbXM6MQ==\" , # qlient specific _fields = [ \"id\" , \"title\" , \"episodeID\" ] ) print ( res . query ) # query film($id: ID) { film(id: $id) { id title episodeID } } print ( res . variables ) # {'id': 'ZmlsbXM6MQ=='} print ( res . data ) # {'film': {'id': 'ZmlsbXM6MQ==', 'title': 'A New Hope', 'episodeID': 4}} (This script is complete and should run \"as is\") What's going on here: When instantiating a new Client, the schema will be automatically resolved from the server and introspected to build the operation proxies. Then a query will be constructed using the given kwargs for variables and special variable _fields for field selection. Now, the query combined with the given variables is sent to the server and a response is returned.","title":"Overview"},{"location":"#overview","text":"A fast and modern graphql client designed with simplicity in mind. Highlights : Automatic graphql query generation. Offline query validation Support for different Backends","title":"Overview"},{"location":"#quick-introduction","text":"qlient inspects the GraphQL schema and generates the corresponding code to use the operations and types in the schema. This provides an easy to use programmatic interface to a GraphQL API.","title":"Quick Introduction"},{"location":"#example","text":"from qlient import Client , GraphQLResponse client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) res : GraphQLResponse = client . query . film ( # swapi graphql input fields id = \"ZmlsbXM6MQ==\" , # qlient specific _fields = [ \"id\" , \"title\" , \"episodeID\" ] ) print ( res . query ) # query film($id: ID) { film(id: $id) { id title episodeID } } print ( res . variables ) # {'id': 'ZmlsbXM6MQ=='} print ( res . data ) # {'film': {'id': 'ZmlsbXM6MQ==', 'title': 'A New Hope', 'episodeID': 4}} (This script is complete and should run \"as is\") What's going on here: When instantiating a new Client, the schema will be automatically resolved from the server and introspected to build the operation proxies. Then a query will be constructed using the given kwargs for variables and special variable _fields for field selection. Now, the query combined with the given variables is sent to the server and a response is returned.","title":"Example"},{"location":"install/","text":"Installation Qlient is a pure-python module. This means that there is no C code which needs to be compiled. This package is build with poetry so installation is as you might expect. pip install qlient or using poetry poetry add qlient","title":"Installation"},{"location":"install/#installation","text":"Qlient is a pure-python module. This means that there is no C code which needs to be compiled. This package is build with poetry so installation is as you might expect. pip install qlient or using poetry poetry add qlient","title":"Installation"},{"location":"examples/project_batches/","text":"","title":"Project batches"},{"location":"examples/script_legend/","text":"(This script is complete and should run \"as is\")","title":"Script legend"},{"location":"usage/backend/","text":"Backends A backend is a service that can take a query, variables and an operation name to create a response. The most common backend is probably going to be some sort of web server, which is why I've made it the default. The default HTTP Backend Below you find an example on instantiating a simple client with an HTTPBackend . from qlient import Client , HTTPBackend , Schema client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) assert isinstance ( client . schema , Schema ) assert isinstance ( client . backend , HTTPBackend ) (This script is complete and should run \"as is\") Customizing the HTTP Backend Session For example let's say you have to do session based authentication. Since the http backend is based on requests, this can be quite easily achieved. import requests from qlient import Client , HTTPBackend session = requests . Session () session . auth = ( \"username\" , \"password\" ) authenticated_backend = HTTPBackend ( endpoint = \"https://...\" , session = session ) client = Client ( authenticated_backend ) assert isinstance ( client . backend , HTTPBackend ) assert client . backend . session == session So what's going on here: A new requests.Session instance is created The session authentication is set A new HTTPBackend with the custom session is created The client with the customized HTTPBackend is created Custom Backends But although a GraphQL API is mostly used in combination with a http backend, it's not solely bound serve over http. For example when using strawberry you can generally just execute queries locally. from typing import List import strawberry # must be installed additionally from qlient import Client , GraphQLResponse from qlient.backend import Backend from qlient.types import ( GraphQLVariables , GraphQLQuery , GraphQLOperation , GraphQLReturnType , GraphQLContext , GraphQLRoot ) @strawberry . type class Book : title : str author : str def get_books (): return [ Book ( title = 'The Great Gatsby' , author = 'F. Scott Fitzgerald' , )] @strawberry . type class Query : books : List [ Book ] = strawberry . field ( resolver = get_books ) # this line creates the strawberry schema my_book_schema = strawberry . Schema ( query = Query ) # now this is the important part # down below we create a custom backend for our client # this backend executes all queries locally using the given strawberry.Schema class StrawberryBackend ( Backend ): def __init__ ( self , schema : strawberry . Schema ): self . schema = schema def execute_query ( self , query : GraphQLQuery , variables : GraphQLVariables = None , operation_name : GraphQLOperation = None , context : GraphQLContext = None , root : GraphQLRoot = None , ) -> GraphQLReturnType : # here we execute the given query on the local strawberry schema # as described in the testing section of the strawberry documentation # https://strawberry.rocks/docs/operations/testing result = self . schema . execute_sync ( query , variables , context , root , operation_name ) return { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , } @property def cache_key ( self ) -> str : # required for caching purposes (not used in this example) return \"CustomStrawberryBookBackend\" client = Client ( StrawberryBackend ( my_book_schema )) response : GraphQLResponse = client . query . books ( _fields = [ \"title\" , \"author\" ]) print ( response . data ) # {'books': [{'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald'}]} (This script is complete and should run \"as is\") So what's going on here: After all imports are done the strawberry schema is created Once we have the schema, it's time to create our backend. For that we must import the base Backend class from qlient.backend . Then we implement the required abstract methods execute_query and add the cache_key property. (Later is used for using the client with a cache. But this is not necessary in this case.) Once we have our custom backend, all we have to do now is to create our client. Now we can use the client just like any other http client","title":"Backends"},{"location":"usage/backend/#backends","text":"A backend is a service that can take a query, variables and an operation name to create a response. The most common backend is probably going to be some sort of web server, which is why I've made it the default.","title":"Backends"},{"location":"usage/backend/#the-default-http-backend","text":"Below you find an example on instantiating a simple client with an HTTPBackend . from qlient import Client , HTTPBackend , Schema client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) assert isinstance ( client . schema , Schema ) assert isinstance ( client . backend , HTTPBackend ) (This script is complete and should run \"as is\")","title":"The default HTTP Backend"},{"location":"usage/backend/#customizing-the-http-backend-session","text":"For example let's say you have to do session based authentication. Since the http backend is based on requests, this can be quite easily achieved. import requests from qlient import Client , HTTPBackend session = requests . Session () session . auth = ( \"username\" , \"password\" ) authenticated_backend = HTTPBackend ( endpoint = \"https://...\" , session = session ) client = Client ( authenticated_backend ) assert isinstance ( client . backend , HTTPBackend ) assert client . backend . session == session So what's going on here: A new requests.Session instance is created The session authentication is set A new HTTPBackend with the custom session is created The client with the customized HTTPBackend is created","title":"Customizing the HTTP Backend Session"},{"location":"usage/backend/#custom-backends","text":"But although a GraphQL API is mostly used in combination with a http backend, it's not solely bound serve over http. For example when using strawberry you can generally just execute queries locally. from typing import List import strawberry # must be installed additionally from qlient import Client , GraphQLResponse from qlient.backend import Backend from qlient.types import ( GraphQLVariables , GraphQLQuery , GraphQLOperation , GraphQLReturnType , GraphQLContext , GraphQLRoot ) @strawberry . type class Book : title : str author : str def get_books (): return [ Book ( title = 'The Great Gatsby' , author = 'F. Scott Fitzgerald' , )] @strawberry . type class Query : books : List [ Book ] = strawberry . field ( resolver = get_books ) # this line creates the strawberry schema my_book_schema = strawberry . Schema ( query = Query ) # now this is the important part # down below we create a custom backend for our client # this backend executes all queries locally using the given strawberry.Schema class StrawberryBackend ( Backend ): def __init__ ( self , schema : strawberry . Schema ): self . schema = schema def execute_query ( self , query : GraphQLQuery , variables : GraphQLVariables = None , operation_name : GraphQLOperation = None , context : GraphQLContext = None , root : GraphQLRoot = None , ) -> GraphQLReturnType : # here we execute the given query on the local strawberry schema # as described in the testing section of the strawberry documentation # https://strawberry.rocks/docs/operations/testing result = self . schema . execute_sync ( query , variables , context , root , operation_name ) return { \"data\" : result . data , \"errors\" : result . errors , \"extensions\" : result . extensions , } @property def cache_key ( self ) -> str : # required for caching purposes (not used in this example) return \"CustomStrawberryBookBackend\" client = Client ( StrawberryBackend ( my_book_schema )) response : GraphQLResponse = client . query . books ( _fields = [ \"title\" , \"author\" ]) print ( response . data ) # {'books': [{'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald'}]} (This script is complete and should run \"as is\") So what's going on here: After all imports are done the strawberry schema is created Once we have the schema, it's time to create our backend. For that we must import the base Backend class from qlient.backend . Then we implement the required abstract methods execute_query and add the cache_key property. (Later is used for using the client with a cache. But this is not necessary in this case.) Once we have our custom backend, all we have to do now is to create our client. Now we can use the client just like any other http client","title":"Custom Backends"},{"location":"usage/cache/","text":"Cache When the client is initialized, it will automatically retrieve the schema using the given provider. By default, qlient does not cache these files, but it is however advised to enable this for performance reasons. This library comes with two built in Caching Backends. InMemoryCache The InMemoryCache caches, as the name suggests, everything in memory. This is useful when you create a lot of clients in a short period of time. from qlient import Client from qlient.cache import InMemoryCache client = Client ( \"https://...\" , cache = InMemoryCache ()) SqliteCache The SqliteCache uses pythons built in sqlite3 package to cache the schema in a .sqlite file. By default, this file is stored in the application cache folder of your operating system. Linux: /home/{USER}/.cache/qlient/schemas.sqlite Windows: C:/Users/{USER}/AppData/Local/qlient/Cache/schemas.sqlite Mac: /Users/{USER}/Library/Caches/qlient/schemas.sqlite However, the path can be adjusted to your liking. from qlient import Client from qlient.cache import SqliteCache client = Client ( \"https://...\" , cache = SqliteCache ()) # or with custom settings client = Client ( \"https://...\" , cache = SqliteCache ( path = \"/path/to/my/schema_cache.sqlite\" , expires_in = 86400 # seconds ) )","title":"Cache"},{"location":"usage/cache/#cache","text":"When the client is initialized, it will automatically retrieve the schema using the given provider. By default, qlient does not cache these files, but it is however advised to enable this for performance reasons. This library comes with two built in Caching Backends.","title":"Cache"},{"location":"usage/cache/#inmemorycache","text":"The InMemoryCache caches, as the name suggests, everything in memory. This is useful when you create a lot of clients in a short period of time. from qlient import Client from qlient.cache import InMemoryCache client = Client ( \"https://...\" , cache = InMemoryCache ())","title":"InMemoryCache"},{"location":"usage/cache/#sqlitecache","text":"The SqliteCache uses pythons built in sqlite3 package to cache the schema in a .sqlite file. By default, this file is stored in the application cache folder of your operating system. Linux: /home/{USER}/.cache/qlient/schemas.sqlite Windows: C:/Users/{USER}/AppData/Local/qlient/Cache/schemas.sqlite Mac: /Users/{USER}/Library/Caches/qlient/schemas.sqlite However, the path can be adjusted to your liking. from qlient import Client from qlient.cache import SqliteCache client = Client ( \"https://...\" , cache = SqliteCache ()) # or with custom settings client = Client ( \"https://...\" , cache = SqliteCache ( path = \"/path/to/my/schema_cache.sqlite\" , expires_in = 86400 # seconds ) )","title":"SqliteCache"},{"location":"usage/client/","text":"Client The Client is the main interface for interacting with the graphql server. It provides the query , mutation and subscription attribute which references the different types of operations (via ServiceProxy class). Configuring a default client The client takes one required argument (the backend ) and several optional arguments which all have an impact on the client behaviour. from qlient import Client , HTTPBackend , Schema client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) assert isinstance ( client . schema , Schema ) assert isinstance ( client . backend , HTTPBackend ) (This script is complete and should run \"as is\") Initiating a client like so will make a request to the graphql server to inspect the schema. For more details on the schema, have a look at the schema documentation . If you want to get to know the backend, have a look at the backend documentation . Making a request Let's say we already have our default client setup. Now how do we make requests? Below is an example for the star wars api from qlient import Client , GraphQLResponse client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) res : GraphQLResponse = client . query . film ( # swapi graphql input fields id = \"ZmlsbXM6MQ==\" , # qlient specific _fields = [ \"id\" , \"title\" , \"episodeID\" ] ) print ( res . query ) # query film($id: ID) { film(id: $id) { id title episodeID } } print ( res . variables ) # {'id': 'ZmlsbXM6MQ=='} print ( res . data ) # {'film': {'id': 'ZmlsbXM6MQ==', 'title': 'A New Hope', 'episodeID': 4}} (This script is complete and should run \"as is\") Selecting nested fields You can use the Fields class to make powerful selections. Say for the example above, you'd also like to have information about the rocket. from qlient import Client , Fields client : Client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) nested_fields = Fields ( people = Fields ( \"id\" , \"name\" , homeworld = \"name\" ) ) response = client . query . allPeople ( first = 3 , _fields = nested_fields ) print ( response . query ) # query allPeople($first: Int) { allPeople(first: $first) { people { id name homeworld { name } } } } (This script is complete and should run \"as is\") For more details on the Fields class, have a look at the fields documentation","title":"Client"},{"location":"usage/client/#client","text":"The Client is the main interface for interacting with the graphql server. It provides the query , mutation and subscription attribute which references the different types of operations (via ServiceProxy class).","title":"Client"},{"location":"usage/client/#configuring-a-default-client","text":"The client takes one required argument (the backend ) and several optional arguments which all have an impact on the client behaviour. from qlient import Client , HTTPBackend , Schema client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) assert isinstance ( client . schema , Schema ) assert isinstance ( client . backend , HTTPBackend ) (This script is complete and should run \"as is\") Initiating a client like so will make a request to the graphql server to inspect the schema. For more details on the schema, have a look at the schema documentation . If you want to get to know the backend, have a look at the backend documentation .","title":"Configuring a default client"},{"location":"usage/client/#making-a-request","text":"Let's say we already have our default client setup. Now how do we make requests? Below is an example for the star wars api from qlient import Client , GraphQLResponse client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) res : GraphQLResponse = client . query . film ( # swapi graphql input fields id = \"ZmlsbXM6MQ==\" , # qlient specific _fields = [ \"id\" , \"title\" , \"episodeID\" ] ) print ( res . query ) # query film($id: ID) { film(id: $id) { id title episodeID } } print ( res . variables ) # {'id': 'ZmlsbXM6MQ=='} print ( res . data ) # {'film': {'id': 'ZmlsbXM6MQ==', 'title': 'A New Hope', 'episodeID': 4}} (This script is complete and should run \"as is\")","title":"Making a request"},{"location":"usage/client/#selecting-nested-fields","text":"You can use the Fields class to make powerful selections. Say for the example above, you'd also like to have information about the rocket. from qlient import Client , Fields client : Client = Client ( \"https://swapi-graphql.netlify.app/.netlify/functions/index\" ) nested_fields = Fields ( people = Fields ( \"id\" , \"name\" , homeworld = \"name\" ) ) response = client . query . allPeople ( first = 3 , _fields = nested_fields ) print ( response . query ) # query allPeople($first: Int) { allPeople(first: $first) { people { id name homeworld { name } } } } (This script is complete and should run \"as is\") For more details on the Fields class, have a look at the fields documentation","title":"Selecting nested fields"},{"location":"usage/fields/","text":"Fields The Fields class is a powerful class for making nested or pre-configured field selections. Nested Fields selection from qlient import Fields nested_fields = Fields ( \"first_name\" , \"last_name\" , hobby = \"name\" ) print ( nested_fields ) last_name first_name hobby { name } (This script is complete and should run \"as is\") The hobby selection can be changed from a single item to a list : from qlient import Fields nested_fields = Fields ( \"first_name\" , \"last_name\" , hobby = [ \"name\" , \"description\" ] ) print ( nested_fields ) last_name first_name hobby { name description } (This script is complete and should run \"as is\") or even another Fields instance for even deeper selection. from qlient import Fields nested_fields = Fields ( \"first_name\" , \"last_name\" , hobby = Fields ( \"name\" , club = \"name\" ) ) print ( nested_fields ) last_name first_name hobby { name club { name } } (This script is complete and should run \"as is\") Supported Operators The Fields class supports two operators: addition and subtraction. Addition from qlient import Fields name = Fields ( \"first_name\" , \"last_name\" ) age = Fields ( \"age\" ) added = name + age print ( added ) first_name last_name age (This script is complete and should run \"as is\") Subtraction from qlient import Fields full_name = Fields ( \"first_name\" , \"last_name\" ) last_name = Fields ( \"last_name\" ) subtracted = full_name - last_name print ( subtracted ) first_name (This script is complete and should run \"as is\")","title":"Fields"},{"location":"usage/fields/#fields","text":"The Fields class is a powerful class for making nested or pre-configured field selections.","title":"Fields"},{"location":"usage/fields/#nested-fields-selection","text":"from qlient import Fields nested_fields = Fields ( \"first_name\" , \"last_name\" , hobby = \"name\" ) print ( nested_fields ) last_name first_name hobby { name } (This script is complete and should run \"as is\") The hobby selection can be changed from a single item to a list : from qlient import Fields nested_fields = Fields ( \"first_name\" , \"last_name\" , hobby = [ \"name\" , \"description\" ] ) print ( nested_fields ) last_name first_name hobby { name description } (This script is complete and should run \"as is\") or even another Fields instance for even deeper selection. from qlient import Fields nested_fields = Fields ( \"first_name\" , \"last_name\" , hobby = Fields ( \"name\" , club = \"name\" ) ) print ( nested_fields ) last_name first_name hobby { name club { name } } (This script is complete and should run \"as is\")","title":"Nested Fields selection"},{"location":"usage/fields/#supported-operators","text":"The Fields class supports two operators: addition and subtraction.","title":"Supported Operators"},{"location":"usage/fields/#addition","text":"from qlient import Fields name = Fields ( \"first_name\" , \"last_name\" ) age = Fields ( \"age\" ) added = name + age print ( added ) first_name last_name age (This script is complete and should run \"as is\")","title":"Addition"},{"location":"usage/fields/#subtraction","text":"from qlient import Fields full_name = Fields ( \"first_name\" , \"last_name\" ) last_name = Fields ( \"last_name\" ) subtracted = full_name - last_name print ( subtracted ) first_name (This script is complete and should run \"as is\")","title":"Subtraction"},{"location":"usage/proxy/","text":"Proxy The OperationProxy object is a simple object which will check if an operation exists for attribute or item requested. If the operation exists then it will return an Operation object (callable) which is responsible for calling the operation on the binding. from qlient import Client client = Client ( \"https://my-graphql-api.com/\" ) # query is a QueryService object (Inherits from OperationProxy). It will check if there # is an operation with the name `X` defined in the binding # and if that is the case it will return a callable Operation object client . query . X () # The operation can also be called via an __getitem__ call. # This is useful if the operation name is not a valid # python attribute name. client . query [ \"X-Y-Z\" ]() # in GraphQL, you can do more than just query data. # for example mutations. client . mutation . changeX () # Subscriptions are not yet supported.","title":"Proxy"},{"location":"usage/proxy/#proxy","text":"The OperationProxy object is a simple object which will check if an operation exists for attribute or item requested. If the operation exists then it will return an Operation object (callable) which is responsible for calling the operation on the binding. from qlient import Client client = Client ( \"https://my-graphql-api.com/\" ) # query is a QueryService object (Inherits from OperationProxy). It will check if there # is an operation with the name `X` defined in the binding # and if that is the case it will return a callable Operation object client . query . X () # The operation can also be called via an __getitem__ call. # This is useful if the operation name is not a valid # python attribute name. client . query [ \"X-Y-Z\" ]() # in GraphQL, you can do more than just query data. # for example mutations. client . mutation . changeX () # Subscriptions are not yet supported.","title":"Proxy"},{"location":"usage/schema/","text":"Schema The schema describes what operations can be made, which inputs can be given and which return values are expected. By default, the schema will be introspected using the BackendSchemaProvider . The BackendSchemaProvider takes the in the client specified backend and uses an introspection query to load the schema from the backend. Custom Schema In some cases, for example when the introspection has been disabled on the graphql backend, you'd want to read the schema from a different location. This can be for example from a local file. Thanks to the SchemaProvider base class, this can quite easily be achieved. Schema from local path Below shows an example that reads the schema from a local path on the file system. from pathlib import Path from qlient import Client , Schema from qlient.schema.providers import FileSchemaProvider path_to_schema = Path ( \"./path/to/my/schema.json\" ) local_schema = Schema ( provider = FileSchemaProvider ( path_to_schema )) client = Client ( \"https://...\" , schema = local_schema ) My schema is neither on my filesystem, nor on any remote Do not fear, solution is near. have a look at the documentation for schema providers","title":"Schema"},{"location":"usage/schema/#schema","text":"The schema describes what operations can be made, which inputs can be given and which return values are expected. By default, the schema will be introspected using the BackendSchemaProvider . The BackendSchemaProvider takes the in the client specified backend and uses an introspection query to load the schema from the backend.","title":"Schema"},{"location":"usage/schema/#custom-schema","text":"In some cases, for example when the introspection has been disabled on the graphql backend, you'd want to read the schema from a different location. This can be for example from a local file. Thanks to the SchemaProvider base class, this can quite easily be achieved.","title":"Custom Schema"},{"location":"usage/schema/#schema-from-local-path","text":"Below shows an example that reads the schema from a local path on the file system. from pathlib import Path from qlient import Client , Schema from qlient.schema.providers import FileSchemaProvider path_to_schema = Path ( \"./path/to/my/schema.json\" ) local_schema = Schema ( provider = FileSchemaProvider ( path_to_schema )) client = Client ( \"https://...\" , schema = local_schema )","title":"Schema from local path"},{"location":"usage/schema/#my-schema-is-neither-on-my-filesystem-nor-on-any-remote","text":"Do not fear, solution is near. have a look at the documentation for schema providers","title":"My schema is neither on my filesystem, nor on any remote"},{"location":"usage/schema_providers/","text":"Schema Providers What if my schema is neither located on my filesystem, nor is it on any backend? Do not fear, solution is near. Under the hood, the schema uses SchemaProvider s. This package comes with three built in providers: The StaticSchemaProvider in case you have a static dictionary with the schema The FileSchemaProvider in case your schema is on your disk The BackendSchemaProvider in case your schema can be obtained from the backend ( Backend Introspection only works when allowed by the graphql backend. ) If neither of these two built in providers suit your needs, you can create your own schema provider like so: from typing import Dict from qlient import Client , Schema from qlient.schema.providers import SchemaProvider class MySchemaProvider ( SchemaProvider ): def load_schema ( self ) -> Dict : # do some logic that loads your schema return { ... } my_schema = Schema ( provider = MySchemaProvider ()) client = Client ( \"https://...\" , schema = my_schema )","title":"Schema Providers"},{"location":"usage/schema_providers/#schema-providers","text":"What if my schema is neither located on my filesystem, nor is it on any backend? Do not fear, solution is near. Under the hood, the schema uses SchemaProvider s. This package comes with three built in providers: The StaticSchemaProvider in case you have a static dictionary with the schema The FileSchemaProvider in case your schema is on your disk The BackendSchemaProvider in case your schema can be obtained from the backend ( Backend Introspection only works when allowed by the graphql backend. ) If neither of these two built in providers suit your needs, you can create your own schema provider like so: from typing import Dict from qlient import Client , Schema from qlient.schema.providers import SchemaProvider class MySchemaProvider ( SchemaProvider ): def load_schema ( self ) -> Dict : # do some logic that loads your schema return { ... } my_schema = Schema ( provider = MySchemaProvider ()) client = Client ( \"https://...\" , schema = my_schema )","title":"Schema Providers"},{"location":"usage/settings/","text":"Settings The client behaviour can be influenced by these settings. from qlient import Settings , Client my_settings = Settings ( introspect = True , # default, enable backend schema introspection validate_fields = True , # default, enable query field selection validation validate_variables = True # default, enable query variable validation ) my_client = Client ( \"https://...\" , settings = my_settings )","title":"Settings"},{"location":"usage/settings/#settings","text":"The client behaviour can be influenced by these settings. from qlient import Settings , Client my_settings = Settings ( introspect = True , # default, enable backend schema introspection validate_fields = True , # default, enable query field selection validation validate_variables = True # default, enable query variable validation ) my_client = Client ( \"https://...\" , settings = my_settings )","title":"Settings"}]}